import 'style-loader!css-loader!codemirror/lib/codemirror.css';
import 'style-loader!css-loader!./cm-night-owl.css';
import 'style-loader!css-Loader!./styles.css';
import 'codemirror/mode/javascript/javascript';
import 'codemirror/mode/jsx/jsx';
import {Appear} from 'mdx-deck';
import {CodeBlock} from './components/code-block';
import {Typical} from './components/typical';
import {example, Example} from './components/example';
import {SplitHeader} from './components/split-header';
export {default as theme} from './theme';

# Rethinking Testing React Applications
## ü§î‚öõÔ∏è
---
## About me

Remove?
---
### Let's start with something profound

<Appear>
  <h2>Testing is Important</h2>
  <img src="public/duh.gif" />
</Appear>
---
export default SplitHeader

## What We're Testing
<CodeBlock>{example}</CodeBlock>
<div style={{border: '2px solid red', padding: '10px'}}>
  <Example />
</div>
---
## Typical Testing In React

<CodeBlock>{Typical}</CodeBlock>
---
## The case against shallow rendering

1. False Confidence
2. Uber-mocking
3. Not taking the user into account
---
# False Confidence
---
# Uber-mocking
---
# Not taking the user into account
---
# It's still OK though

- Provider components
---
# Always Be Considering
---
# Test from the perspective of the user not the developer or the code
---
# Testing in broad strokes
---
# Yes, this is integration testing of a sort
---
# Integration vs Unit 
---
# Lots of logic in UI is a code smell

- Pull logic out into module and unit test
- Mocking instance methods is code smell, move into modules
---
# Test UI in sensible chunks

- Yes it makes sense to test that a button component functions properly on it's own
- If component only makes sense in context of surrounding components, test the bigger picture
---
# Cypress for e2e or integration+
---
# Mocking/Stubbing in e2e 

Consider your application and your environment. Ideally, a e2e test is truly e2e, but we don't
always have that luxury. Staging dbs for testing, resetting, auth, etc can sometimes stand in 
they way. Containerization and the ease of spinning up a cloud service helps a lot, so use those
if available and test as wide as possible.

However, if you are constrained, don't feel like you have to ignore these tests. There's nothing
wrong with mocking out the backend API calls and making sure your frontend app works properly. 
---
# Confidence > Coverage

I'd rather have 50% coverage but be 100% confident that the vital parts won't break, than have
100% coverage and need to have tums and a pager on my nightstand.
---
# The end