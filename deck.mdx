import {Appear, Notes} from 'mdx-deck';
import {Example} from './components/example';
import {SplitHeader} from './components/split-header';
import {CodeSurfer} from 'mdx-deck-code-surfer';
import nightOwl from 'prism-react-renderer/themes/nightOwl';
import TopLayout from './components/top-layout';
import {FalseConf2} from './components/false-conf2';
import {BadFalseConf2} from './components/false-conf2-broken'
export {default as theme} from './theme';

# Rethinking Testing React Applications
## 🤔⚛️
---
## About This Talk

```notes
- Entirely subjective
- What's important is what fits for you/your team
- Not a slam of enzyme, purely personal preference
```
---
### Let's start with something profound

```notes
- Obvious, but why exactly
- less bugs, protect from regressions,
- Confidence -> Shipping better code -> no late night pages
```

<Appear>
  <h2>Testing is Important</h2>
  <img src={require('file-loader!./public/duh.gif')} />
</Appear>

---
```notes
- Simple component with basic state and click handlers
- obviously contrived, but you get the idea
```

<CodeSurfer title="What We're Testing" theme={nightOwl} code={require('!raw-loader!./components/example.js')} />
---
export default TopLayout

## What We're Testing

<Example />
---
<CodeSurfer 
  title="Typical Testing In React" 
  theme={nightOwl}
  code={require('!raw-loader!./components/typical.test.js')}
  steps={[
    {range: [1, 4], notes: 'Import the necessary stuff'},
    {range: [6, 9], notes: 'Test the intial state'},
    {range: [11, 18], notes: 'Test the decrement click'},
    {range: [20, 27], notes: 'Test the increment click'}
  ]}
/>
---
## The case against shallow rendering

<ol style={{textAlign: 'left', fontSize: '1.5em'}}>
  <Appear>
    <li>Testing implementation details</li>
    <li>False Confidence</li>
    <li>Not taking the user into account</li>
  </Appear>
</ol>

```notes
- prev test look fine right?
- there are issues though 
- everything has tradeoffs
```
---
<CodeSurfer
  title="A Simple Refactor..."
  theme={nightOwl}
  code={require('!raw-loader!./components/imp-details.js')}
  steps={[
    {lines: [2, 27, 29], notes: ''}
  ]}
/>
---
## Means Broken Tests

❌❌❌❌😭
---
```notes
- Not the only way to fix
- Could use Component Constructors, displayName, or prop selectors
- but those are all still instances of testing implementation details
```

<CodeSurfer
  title="So Update the Tests"
  theme={nightOwl}
  code={require('!raw-loader!./components/imp-details.test.js')}
  steps={[
    {lines: [13, 19]}
  ]}
/>
---
## False Confidence

```notes
- shallow often requires bending things to our will to make tests pass
- we've see green in the console
- user sees red
```
---
```notes
- stupid, contrived example
- just one counter, but assume maybe a number of counters
```

<CodeSurfer
  title="Another simple refactor..."
  theme={nightOwl}
  code={require('!raw-loader!./components/false-conf1.js')}
  steps={[
    {lines: [3, 29], notes: 'Adding some kind of display component'}
  ]}
/>
---
<CodeSurfer
  title="Tests Are Broken, So Now Fix"
  theme={nightOwl}
  code={require('!raw-loader!./components/false-conf1.test.js')}
  steps={[
    {lines: [14, 20]}
  ]}
/>
---
<CodeSurfer
  title="A Bad Change in the Display Component"
  theme={nightOwl}
  code={require('!raw-loader!./components/display-code.js')}
  steps={[
    {range: [3, 7]},
    {lines: [9]},
  ]}
/>
---
export default TopLayout

## Yeah That's Not Right

<BadFalseConf2 />
---
## Tests Still Passing

## 😭😭😭😭😭
---
## Why Not Shallow Rendering?

<ul style={{textAlign: 'left', fontSize: '1.5em'}}>
  <li>Testing Implementation Details
    <ul>
      <li>Top priority is to ensure the app is working</li>
      <li>Focus on end result, not details</li>
    </ul>
  </li>
  <li>False Confidence
    <ul>
      <li>Something broken lower in the tree might not surface</li>
      <li>Relying on untested (at this level) code to be right</li>
    </ul>
  </li>
  <li>Not taking the user into account</li>
</ul>

---
```notes
- providers are mostly logic based
- do a shallow render and verify values are generated/provided correctly
```

## Where Shallow Is Still Good

- Provider components
---
## Enter React-Testing-Library

<ul style={{textAlign: 'left', fontSize: '1.5em'}}>
  <Appear>
    <li>Testing UI from User perspective, not implementation details</li>
    <li>Much higher confidence</li>
  </Appear>
</ul>
---
## Test from the perspective of the user
---
# Testing in broad strokes
---
# Yes, this is integration testing of a sort
---
# Integration vs Unit 
---
# Lots of logic in UI is a code smell

- Pull logic out into module and unit test
- Mocking instance methods is code smell, move into modules
---
# Test UI in sensible chunks

- Yes it makes sense to test that a button component functions properly on it's own
- If component only makes sense in context of surrounding components, test the bigger picture
---
# Cypress for e2e or integration+
---
# Mocking/Stubbing in e2e 

Consider your application and your environment. Ideally, a e2e test is truly e2e, but we don't
always have that luxury. Staging dbs for testing, resetting, auth, etc can sometimes stand in 
they way. Containerization and the ease of spinning up a cloud service helps a lot, so use those
if available and test as wide as possible.

However, if you are constrained, don't feel like you have to ignore these tests. There's nothing
wrong with mocking out the backend API calls and making sure your frontend app works properly. 
---
# Confidence > Coverage

I'd rather have 50% coverage but be 100% confident that the vital parts won't break, than have
100% coverage and need to have tums and a pager on my nightstand.
---
# The end