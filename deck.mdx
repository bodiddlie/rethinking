import {Appear, Notes} from 'mdx-deck';
import {Example} from './components/example';
import {SplitHeader} from './components/split-header';
import {CodeSurfer} from 'mdx-deck-code-surfer';
import nightOwl from 'prism-react-renderer/themes/nightOwl';
import TopLayout from './components/top-layout';
export {default as theme} from './theme';

# Rethinking Testing React Applications
## 🤔⚛️
---
## About This Talk

```notes
- Entirely subjective
- What's important is what fits for you/your team
- Not a slam of enzyme, purely personal preference
```
---
### Let's start with something profound

```notes
- Obvious, but why exactly
- less bugs, protect from regressions,
- Confidence -> Shipping better code -> no late night pages
```

<Appear>
  <h2>Testing is Important</h2>
  <img src={require('file-loader!./public/duh.gif')} />
</Appear>

---
```notes
- Simple component with basic state and click handlers
```

<CodeSurfer title="What We're Testing" theme={nightOwl} code={require('!raw-loader!./components/example.js')} />
---
export default TopLayout

## What We're Testing

<Example />
---
<CodeSurfer 
  title="Typical Testing In React" 
  theme={nightOwl}
  code={require('!raw-loader!./components/typical.test.js')}
  steps={[
    {range: [1, 4], notes: 'Import the necessary stuff'},
    {range: [6, 9], notes: 'Test the intial state'},
    {range: [11, 18], notes: 'Test the decrement click'},
    {range: [20, 27], notes: 'Test the increment click'}
  ]}
/>
---
## The case against shallow rendering

1. Testing implementation details
2. False Confidence
3. Not taking the user into account

```notes
- prev test look fine right?
- there are issues though 
- everything has tradeoffs
```
---
<CodeSurfer
  title="A Simple Refactor"
  theme={nightOwl}
  code={require('!raw-loader!./components/imp-details.js')}
  steps={[
    {lines: [2, 27, 29], notes: ''}
  ]}
/>
---
## Testing Implementation Details

- Top priority is to ensure the app is working
- Focus on end result, not details

```notes
- ultimately what we care about is that the app works for the user
- focus on end result, not details
```
---
# False Confidence
---
# Not taking the user into account
---
# It's still OK though

- Provider components
---
# Always Be Considering
---
# Test from the perspective of the user not the developer or the code
---
# Testing in broad strokes
---
# Yes, this is integration testing of a sort
---
# Integration vs Unit 
---
# Lots of logic in UI is a code smell

- Pull logic out into module and unit test
- Mocking instance methods is code smell, move into modules
---
# Test UI in sensible chunks

- Yes it makes sense to test that a button component functions properly on it's own
- If component only makes sense in context of surrounding components, test the bigger picture
---
# Cypress for e2e or integration+
---
# Mocking/Stubbing in e2e 

Consider your application and your environment. Ideally, a e2e test is truly e2e, but we don't
always have that luxury. Staging dbs for testing, resetting, auth, etc can sometimes stand in 
they way. Containerization and the ease of spinning up a cloud service helps a lot, so use those
if available and test as wide as possible.

However, if you are constrained, don't feel like you have to ignore these tests. There's nothing
wrong with mocking out the backend API calls and making sure your frontend app works properly. 
---
# Confidence > Coverage

I'd rather have 50% coverage but be 100% confident that the vital parts won't break, than have
100% coverage and need to have tums and a pager on my nightstand.
---
# The end